# -*- coding: utf-8 -*-
"""Práctica Perceptron_Adaline_OR.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1nD-g3f_UKxV_MJaRWW9_Be56hieVgZxI
"""

# Combinaciones de entrada de la puerta lógica OR
data = [[-1,-1],
        [-1,1],
        [1,-1],
        [1,1]]

target = [-1,
          1,
          1,
          1]

print("data:", data)
print("target:", target)

'''
Se inicializan los pesos w1, w2 y el sesgo b.
También se establece la tasa de aprendizaje (lr)
y el número de iteraciones (iteraciones).
'''
from tabulate import tabulate

w1 = 0.9
w2 = 0.9
b = 0.9

lr = 0.5

iteractions = 3

'''
El perceptrón se entrena para ajustar sus pesos de acuerdo
con el error (e).
Los resultados de cada iteración se almacenan en data_out.
'''
data_out = [ ]
weigths = [ ]
weigths.append( [w1, w2, b])

for epoch in range ( iteractions):

  for x,y in zip (data,target):
    yin = w1*x[0] + w2*x[1] + b

    if ( yin >= 0.5  ):
       yin = 1
    else:
       yin = 0

    e = y-yin


    if int(y) != int(yin):
      w1 = w1 + lr*e*x[0]
      w2 = w2 + lr*e*x[1]
      b = b + lr*e
      weigths.append( [w1, w2, b])

    data_out.append(  [epoch, x[0], x[1], yin, y, y, e, '-', w1,w2,b, int(y) != int(yin)] )

  data_out.append (['-','-','-','-','-','-','-','-','-','-','-'])

'''
La librería tabulate se utiliza para imprimir una tabla
que muestra los detalles de cada iteración.
'''

print(tabulate( data_out,
                headers=['Epoch', 'x1', 'x2', 'yin', 'y', 't', 'E','-', 'w1', 'w2','b', 'update']))

'''
Se usa Matplotlib para visualizar gráficamente
cómo evolucionan los pesos y la línea de decisión
durante el entrenamiento del perceptrón
'''
import numpy as np
import matplotlib.pyplot as plt

a,b,c = w1,w2,b

data_arr = np.array( data )

x_min = min( data_arr[: ,0 ]-1)
x_max = max( data_arr[: ,0 ]+1)

x = np.linspace(x_min, x_max, 100)

pairs = []

for ws in weigths:
  it = []
  for xi in  x :
    y = (-ws[2] -ws[0]*xi) /ws[1];
    it.append( [xi,y])

  pairs.append(it)
  print(ws)

data_arr = np.array( data )
data_arr_x = data_arr [ : , 0 ]
data_arr_y = data_arr [ : , 1 ]

pairs = np.array(pairs)

plt.figure(1)

fig, axis = plt.subplots(2, 3)

for idx,idy in zip ( data_arr_x, data_arr_y  ):
    axis[0,0].scatter(idx, idy )
    axis[0,1].scatter(idx, idy )
    axis[0,2].scatter(idx, idy )
    axis[1,0].scatter(idx, idy )

axis[0,0].scatter(pairs[0,: ,0], pairs[0, :,1] )
axis[0,1].scatter(pairs[1,: ,0], pairs[1, :,1]  )
axis[0,2].scatter(pairs[2,: ,0], pairs[2, :,1]  )
axis[1,0].scatter(pairs[3,: ,0], pairs[3, :,1]  )